import{A as d}from"./config-8gd_ljfe.js";const h={DB_NAME:d.DB_NAME,DB_VERSION:d.DB_VERSION,STORE_NAME:"words",META_STORE:"meta",NOTES_STORE:"notes",TRAINING_STORE:"training",db:null,isReady:!1,async init(){return this.db?!0:new Promise((t,e)=>{const o=indexedDB.open(this.DB_NAME,this.DB_VERSION);o.onerror=s=>{console.error("[DB] Error opening database:",s.target.error),e(s.target.error)},o.onsuccess=s=>{this.db=s.target.result,this.isReady=!0,console.log("[DB] Database opened successfully"),t(!0)},o.onupgradeneeded=s=>{const r=s.target.result;if(!r.objectStoreNames.contains(this.STORE_NAME)){const n=r.createObjectStore(this.STORE_NAME,{keyPath:"id"});n.createIndex("swedish","swe",{unique:!1}),n.createIndex("arabic","arb",{unique:!1}),n.createIndex("type","type",{unique:!1}),console.log("[DB] Words store created")}if(r.objectStoreNames.contains(this.META_STORE)||(r.createObjectStore(this.META_STORE,{keyPath:"key"}),console.log("[DB] Meta store created")),r.objectStoreNames.contains(this.NOTES_STORE)||(r.createObjectStore(this.NOTES_STORE,{keyPath:"id"}),console.log("[DB] Notes store created")),!r.objectStoreNames.contains(this.TRAINING_STORE))r.createObjectStore(this.TRAINING_STORE,{keyPath:"id"}).createIndex("addedAt","addedAt",{unique:!1}),console.log("[DB] Training store created with addedAt index");else{const n=s.target.transaction;if(n){const i=n.objectStore(this.TRAINING_STORE);i.indexNames.contains("addedAt")||(i.createIndex("addedAt","addedAt",{unique:!1}),console.log("[DB] Added addedAt index to existing training store"))}}}})},async getDataVersion(){return this.db||await this.init(),this.db?new Promise(t=>{try{const s=this.db.transaction([this.META_STORE],"readonly").objectStore(this.META_STORE).get("dataVersion");s.onsuccess=()=>{var r;t(((r=s.result)==null?void 0:r.value)||null)},s.onerror=()=>t(null)}catch{t(null)}}):null},async setDataVersion(t){return this.db||await this.init(),this.db?new Promise((e,o)=>{const s=this.db.transaction([this.META_STORE],"readwrite");s.objectStore(this.META_STORE).put({key:"dataVersion",value:t}),s.oncomplete=()=>e(!0),s.onerror=n=>o(n)}):!1},async getWordCount(){return this.db||await this.init(),this.db?new Promise(t=>{try{const s=this.db.transaction([this.STORE_NAME],"readonly").objectStore(this.STORE_NAME).count();s.onsuccess=()=>t(s.result),s.onerror=()=>t(0)}catch{t(0)}}):0},async saveWords(t,e=null){this.db||await this.init();const o=1e3,s=Math.ceil(t.length/o);console.log(`[DB] Saving ${t.length} words in ${s} batches...`);for(let r=0;r<s;r++){const n=r*o,i=Math.min(n+o,t.length),c=t.slice(n,i);if(await this._saveBatch(c),e){const l=Math.round((r+1)/s*100);e(l)}}return console.log("[DB] All words saved successfully"),!0},async _saveBatch(t){return this.db?new Promise((e,o)=>{const s=this.db.transaction([this.STORE_NAME],"readwrite"),r=s.objectStore(this.STORE_NAME);t.forEach(n=>{const i={id:n[d.COLUMNS.ID],type:n[d.COLUMNS.TYPE],swe:n[d.COLUMNS.SWEDISH],arb:n[d.COLUMNS.ARABIC],arbExt:n[d.COLUMNS.ARABIC_EXT],sweDef:n[d.COLUMNS.DEFINITION],forms:n[d.COLUMNS.FORMS],sweEx:n[d.COLUMNS.EXAMPLE_SWE],arbEx:n[d.COLUMNS.EXAMPLE_ARB],idiomSwe:n[d.COLUMNS.IDIOM_SWE],idiomArb:n[d.COLUMNS.IDIOM_ARB],raw:n};r.put(i)}),s.oncomplete=()=>e(!0),s.onerror=n=>o(n)}):!1},async getAllWords(t=null){return this.db||await this.init(),this.db?new Promise((e,o)=>{const n=this.db.transaction([this.STORE_NAME],"readonly").objectStore(this.STORE_NAME).getAll();n.onsuccess=()=>{const i=n.result.map(c=>c.raw);t&&t(100),console.log(`[DB] Retrieved ${i.length} words from cache`),e(i)},n.onerror=i=>{console.error("[DB] Error getting words:",i),o(i)}}):[]},async hasCachedData(){return await this.getWordCount()>0},async clearCache(){return this.db||await this.init(),this.db?new Promise((t,e)=>{const o=this.db.transaction([this.STORE_NAME,this.META_STORE],"readwrite");o.objectStore(this.STORE_NAME).clear(),o.objectStore(this.META_STORE).clear(),o.oncomplete=()=>{console.log("[DB] Cache cleared"),t(!0)},o.onerror=s=>e(s)}):!1},async getWordById(t){return this.db||await this.init(),this.db?new Promise(e=>{try{const r=this.db.transaction([this.STORE_NAME],"readonly").objectStore(this.STORE_NAME).get(t);r.onsuccess=()=>{r.result&&r.result.raw?e(r.result.raw):e(null)},r.onerror=()=>e(null)}catch(o){console.error("[DB] getWordById error:",o),e(null)}}):null},async getRandomWord(){return this.db||await this.init(),this.db?new Promise(async t=>{try{const e=await this.getWordCount();if(e===0){t(null);return}const o=Math.floor(Math.random()*e),n=this.db.transaction([this.STORE_NAME],"readonly").objectStore(this.STORE_NAME).openCursor();let i=!1;n.onsuccess=c=>{const l=c.target.result;if(!l){t(null);return}if(!i&&o>0)i=!0,l.advance(o);else{const a=l.value.raw||l.value;a&&(a.swedish||a.swe)?(!a.swedish&&a.swe&&(a.swedish=a.swe),!a.arabic&&a.arb&&(a.arabic=a.arb),t(a)):t(null)}},n.onerror=()=>t(null)}catch(e){console.error("[DB] getRandomWord error:",e),t(null)}}):null},async saveWord(t){return this.db||await this.init(),this.db?new Promise((e,o)=>{const s=this.db.transaction([this.STORE_NAME],"readwrite");s.objectStore(this.STORE_NAME).put(t),s.oncomplete=()=>e(!0),s.onerror=n=>o(n)}):!1},async deleteWord(t){return this.db||await this.init(),this.db?new Promise((e,o)=>{const s=this.db.transaction([this.STORE_NAME],"readwrite");s.objectStore(this.STORE_NAME).delete(t),s.oncomplete=()=>e(!0),s.onerror=n=>o(n)}):!1},async getNote(t){return this.db||await this.init(),this.db?new Promise(e=>{try{const r=this.db.transaction([this.NOTES_STORE],"readonly").objectStore(this.NOTES_STORE).get(t);r.onsuccess=()=>{var n;e(((n=r.result)==null?void 0:n.text)||null)},r.onerror=()=>e(null)}catch{e(null)}}):null},async saveNote(t,e){return this.db||await this.init(),this.db?new Promise((o,s)=>{const r=this.db.transaction([this.NOTES_STORE],"readwrite");r.objectStore(this.NOTES_STORE).put({id:t,text:e,updatedAt:Date.now()}),r.oncomplete=()=>o(!0),r.onerror=i=>s(i)}):!1},async updateTrainingStatus(t,e){if(!t){console.warn("[DB] updateTrainingStatus called with empty wordId");return}if(this.db||await this.init(),!!this.db)return new Promise(o=>{const s=this.db.transaction([this.TRAINING_STORE],"readwrite"),r=s.objectStore(this.TRAINING_STORE);e?r.put({id:t,addedAt:Date.now()}):r.delete(t),s.oncomplete=()=>{console.log(`[DB] Training status updated for ${t}: ${e}`),o()},s.onerror=n=>{console.error("[DB] Error updating training status:",n),o()}})},async ensureCustomWord(t){if(this.db||await this.init(),!!this.db)return new Promise((e,o)=>{const s=this.db.transaction([this.STORE_NAME],"readwrite"),r=s.objectStore(this.STORE_NAME),n=r.get(t.id);n.onsuccess=()=>{n.result||(r.put(t),console.log(`[DB] Custom word ${t.id} created`))},s.oncomplete=()=>e(),s.onerror=i=>o(i)})},async getTrainingWords(){return this.db||await this.init(),this.db?new Promise((t,e)=>{const o=this.db.transaction([this.TRAINING_STORE,this.STORE_NAME],"readonly"),s=o.objectStore(this.TRAINING_STORE),r=o.objectStore(this.STORE_NAME),n=s.index("addedAt").getAll();n.onsuccess=async()=>{const i=n.result;if(i.length===0){console.log("[DB] Found 0 words for training"),t([]);return}const c=[];let l=0;for(const a of i){const u=r.get(a.id);u.onsuccess=()=>{u.result?c.push(u.result.raw||u.result):c.push({id:a.id}),l++,l===i.length&&(console.log(`[DB] Found ${c.length} words for training`),t(c))},u.onerror=()=>{l++,l===i.length&&(console.log(`[DB] Found ${c.length} words for training`),t(c))}}},n.onerror=i=>e(i)}):[]},async isWordMarkedForTraining(t){return this.db||await this.init(),this.db?new Promise(e=>{const r=this.db.transaction([this.TRAINING_STORE],"readonly").objectStore(this.TRAINING_STORE).get(t);r.onsuccess=()=>{e(!!r.result)},r.onerror=()=>e(!1)}):!1},async updateReviewData(t,e){if(t&&(this.db||await this.init(),!!this.db))return new Promise((o,s)=>{const r=this.db.transaction([this.TRAINING_STORE],"readwrite"),n=r.objectStore(this.TRAINING_STORE),i=n.get(t);i.onsuccess=()=>{const l={...i.result||{id:t,addedAt:Date.now()},...e};n.put(l)},r.oncomplete=()=>{console.log(`[DB] Review data updated for ${t}`),o()},r.onerror=c=>s(c)})},async getTrainingWordsDue(){const t=await this.getTrainingWords(),e=Date.now();return this.db||await this.init(),this.db?new Promise(o=>{const n=this.db.transaction([this.TRAINING_STORE],"readonly").objectStore(this.TRAINING_STORE).getAll();n.onsuccess=()=>{const i=n.result,c=new Map(i.map(a=>[a.id,a])),l=t.filter(a=>{const u=Array.isArray(a)?a[0]:a.id,S=c.get(u);return S!=null&&S.nextReview?S.nextReview<=e:!0});l.sort((a,u)=>{const S=Array.isArray(a)?a[0]:a.id,w=Array.isArray(u)?u[0]:u.id,f=c.get(S),E=c.get(w);return f!=null&&f.nextReview?E!=null&&E.nextReview?f.nextReview-E.nextReview:1:-1}),console.log(`[DB] Found ${l.length} words due for review`),o(l)},n.onerror=()=>o(t)}):t},async getReviewData(t){return this.db||await this.init(),this.db?new Promise(e=>{const r=this.db.transaction([this.TRAINING_STORE],"readonly").objectStore(this.TRAINING_STORE).get(t);r.onsuccess=()=>e(r.result||null),r.onerror=()=>e(null)}):null},async saveTrainingSession(t){const e="training_sessions",o=JSON.parse(localStorage.getItem(e)||"[]");o.push(t);const s=o.slice(-30);localStorage.setItem(e,JSON.stringify(s))},getTrainingSessions(){return JSON.parse(localStorage.getItem("training_sessions")||"[]")}},T={async loadDictionary(t=null,e=null){try{await h.init();const o=await h.getDataVersion();if(await h.hasCachedData()&&o===d.DATA_VERSION)return e&&e("Laddar från cache... / جاري التحميل من الذاكرة..."),console.log("[DataLoader] Using cached data (version:",o,")"),await h.getAllWords(t);e&&e("Laddar ordbok... / جاري تحميل القاموس..."),console.log("[DataLoader] Loading fresh data from data.js");let r=window.dictionaryData;if(typeof r>"u"||!r.length){e&&e("Laddar datafil... / جاري تحميل ملف البيانات..."),console.log("[DataLoader] Global data missing, fetching from",d.DATA_PATH.root);try{const n=await fetch(d.DATA_PATH.root);if(!n.ok)throw new Error(`HTTP ${n.status}`);r=await n.json(),window.dictionaryData=r}catch(n){throw console.error("[DataLoader] Fetch failed:",n),new Error("dictionaryData could not be loaded")}}return e&&e("Sparar i cache... / جاري الحفظ..."),await h.saveWords(r,t),await h.setDataVersion(d.DATA_VERSION),console.log("[DataLoader] Data cached successfully"),r}catch(o){console.error("[DataLoader] Error:",o);const s=window.dictionaryData;if(typeof s<"u")return s;throw o}},async refreshCache(t=null){return await h.clearCache(),this.loadDictionary(t)}};typeof window<"u"&&(window.DictionaryDB=h,window.DataLoader=T,window.DATA_VERSION=d.DATA_VERSION);export{T as DataLoader,h as DictionaryDB};
