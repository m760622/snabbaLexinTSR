import{A as i}from"./config-CfHoVMbv.js";const c={DB_NAME:i.DB_NAME,DB_VERSION:i.DB_VERSION,STORE_NAME:"words",META_STORE:"meta",NOTES_STORE:"notes",db:null,isReady:!1,async init(){return this.db?!0:new Promise((e,s)=>{const o=indexedDB.open(this.DB_NAME,this.DB_VERSION);o.onerror=t=>{console.error("[DB] Error opening database:",t.target.error),s(t.target.error)},o.onsuccess=t=>{this.db=t.target.result,this.isReady=!0,console.log("[DB] Database opened successfully"),e(!0)},o.onupgradeneeded=t=>{const r=t.target.result;if(!r.objectStoreNames.contains(this.STORE_NAME)){const a=r.createObjectStore(this.STORE_NAME,{keyPath:"id"});a.createIndex("swedish","swe",{unique:!1}),a.createIndex("arabic","arb",{unique:!1}),a.createIndex("type","type",{unique:!1}),console.log("[DB] Words store created")}r.objectStoreNames.contains(this.META_STORE)||(r.createObjectStore(this.META_STORE,{keyPath:"key"}),console.log("[DB] Meta store created")),r.objectStoreNames.contains(this.NOTES_STORE)||(r.createObjectStore(this.NOTES_STORE,{keyPath:"id"}),console.log("[DB] Notes store created"))}})},async getDataVersion(){return this.db||await this.init(),this.db?new Promise(e=>{try{const t=this.db.transaction([this.META_STORE],"readonly").objectStore(this.META_STORE).get("dataVersion");t.onsuccess=()=>{var r;e(((r=t.result)==null?void 0:r.value)||null)},t.onerror=()=>e(null)}catch{e(null)}}):null},async setDataVersion(e){return this.db||await this.init(),this.db?new Promise((s,o)=>{const t=this.db.transaction([this.META_STORE],"readwrite");t.objectStore(this.META_STORE).put({key:"dataVersion",value:e}),t.oncomplete=()=>s(!0),t.onerror=a=>o(a)}):!1},async getWordCount(){return this.db||await this.init(),this.db?new Promise(e=>{try{const t=this.db.transaction([this.STORE_NAME],"readonly").objectStore(this.STORE_NAME).count();t.onsuccess=()=>e(t.result),t.onerror=()=>e(0)}catch{e(0)}}):0},async saveWords(e,s=null){this.db||await this.init();const o=1e3,t=Math.ceil(e.length/o);console.log(`[DB] Saving ${e.length} words in ${t} batches...`);for(let r=0;r<t;r++){const a=r*o,n=Math.min(a+o,e.length),d=e.slice(a,n);if(await this._saveBatch(d),s){const h=Math.round((r+1)/t*100);s(h)}}return console.log("[DB] All words saved successfully"),!0},async _saveBatch(e){return this.db?new Promise((s,o)=>{const t=this.db.transaction([this.STORE_NAME],"readwrite"),r=t.objectStore(this.STORE_NAME);e.forEach(a=>{const n={id:a[i.COLUMNS.ID],type:a[i.COLUMNS.TYPE],swe:a[i.COLUMNS.SWEDISH],arb:a[i.COLUMNS.ARABIC],arbExt:a[i.COLUMNS.ARABIC_EXT],sweDef:a[i.COLUMNS.DEFINITION],forms:a[i.COLUMNS.FORMS],sweEx:a[i.COLUMNS.EXAMPLE_SWE],arbEx:a[i.COLUMNS.EXAMPLE_ARB],idiomSwe:a[i.COLUMNS.IDIOM_SWE],idiomArb:a[i.COLUMNS.IDIOM_ARB],raw:a};r.put(n)}),t.oncomplete=()=>s(!0),t.onerror=a=>o(a)}):!1},async getAllWords(e=null){return this.db||await this.init(),this.db?new Promise((s,o)=>{const a=this.db.transaction([this.STORE_NAME],"readonly").objectStore(this.STORE_NAME).getAll();a.onsuccess=()=>{const n=a.result.map(d=>d.raw);e&&e(100),console.log(`[DB] Retrieved ${n.length} words from cache`),s(n)},a.onerror=n=>{console.error("[DB] Error getting words:",n),o(n)}}):[]},async hasCachedData(){return await this.getWordCount()>0},async clearCache(){return this.db||await this.init(),this.db?new Promise((e,s)=>{const o=this.db.transaction([this.STORE_NAME,this.META_STORE],"readwrite");o.objectStore(this.STORE_NAME).clear(),o.objectStore(this.META_STORE).clear(),o.oncomplete=()=>{console.log("[DB] Cache cleared"),e(!0)},o.onerror=t=>s(t)}):!1},async getWordById(e){return this.db||await this.init(),this.db?new Promise(s=>{try{const r=this.db.transaction([this.STORE_NAME],"readonly").objectStore(this.STORE_NAME).get(e);r.onsuccess=()=>{r.result&&r.result.raw?s(r.result.raw):s(null)},r.onerror=()=>s(null)}catch(o){console.error("[DB] getWordById error:",o),s(null)}}):null},async saveWord(e){return this.db||await this.init(),this.db?new Promise((s,o)=>{const t=this.db.transaction([this.STORE_NAME],"readwrite");t.objectStore(this.STORE_NAME).put(e),t.oncomplete=()=>s(!0),t.onerror=a=>o(a)}):!1},async deleteWord(e){return this.db||await this.init(),this.db?new Promise((s,o)=>{const t=this.db.transaction([this.STORE_NAME],"readwrite");t.objectStore(this.STORE_NAME).delete(e),t.oncomplete=()=>s(!0),t.onerror=a=>o(a)}):!1},async getNote(e){return this.db||await this.init(),this.db?new Promise(s=>{try{const r=this.db.transaction([this.NOTES_STORE],"readonly").objectStore(this.NOTES_STORE).get(e);r.onsuccess=()=>{var a;s(((a=r.result)==null?void 0:a.text)||null)},r.onerror=()=>s(null)}catch{s(null)}}):null},async saveNote(e,s){return this.db||await this.init(),this.db?new Promise((o,t)=>{const r=this.db.transaction([this.NOTES_STORE],"readwrite");r.objectStore(this.NOTES_STORE).put({id:e,text:s,updatedAt:Date.now()}),r.oncomplete=()=>o(!0),r.onerror=n=>t(n)}):!1}},l={async loadDictionary(e=null,s=null){try{await c.init();const o=await c.getDataVersion();if(await c.hasCachedData()&&o===i.DATA_VERSION)return s&&s("Laddar från cache... / جاري التحميل من الذاكرة..."),console.log("[DataLoader] Using cached data (version:",o,")"),await c.getAllWords(e);s&&s("Laddar ordbok... / جاري تحميل القاموس..."),console.log("[DataLoader] Loading fresh data from data.js");const r=window.dictionaryData;if(typeof r>"u"||!r.length)throw new Error("dictionaryData not loaded from data.js");return s&&s("Sparar i cache... / جاري الحفظ..."),await c.saveWords(r,e),await c.setDataVersion(i.DATA_VERSION),console.log("[DataLoader] Data cached successfully"),r}catch(o){console.error("[DataLoader] Error:",o);const t=window.dictionaryData;if(typeof t<"u")return t;throw o}},async refreshCache(e=null){return await c.clearCache(),this.loadDictionary(e)}};typeof window<"u"&&(window.DictionaryDB=c,window.DataLoader=l,window.DATA_VERSION=i.DATA_VERSION);export{c as D};
